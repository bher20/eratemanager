image:
  repository: ghcr.io/bher20/eratemanager
  tag: latest
  pullPolicy: IfNotPresent

replicaCount: 1

# PostgreSQL subchart configuration
postgresql:
  enabled: true
  auth:
    username: postgres
    password: password
    database: eratemanager
  image:
    registry: docker.io
    repository: bitnami/postgresql
    tag: latest

db:
  # Use Postgres (postgrespool for connection pooling)
  driver: "postgrespool"
  dsn: "postgres://postgres:password@eratemanager-postgresql:5432/eratemanager?sslmode=disable"

cronWorker:
  enabled: false
  # Interval in seconds between batch refresh runs.
  intervalSeconds: 3600
  replicaCount: 1
  resources: {}
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80


service:
  type: ClusterIP
  port: 80

app:
  port: 8000

# Providers are now discovered dynamically via the /providers API endpoint.
# No need to list them here - the helm chart will query the running application.

# Refresh hook runs after install/upgrade to populate data for all discovered providers
refreshHook:
  enabled: true

persistence:
  enabled: true
  size: 1Gi
  mountPath: /data

cron:
  enabled: true
  schedule: "0 3 * * *"

gateway:
  enabled: true
  name: public-gateway
  namespace: default
  hostname: rates.example.com

monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    namespace: ""
    interval: 30s
    scrapeTimeout: 10s
    labels: {}

hpa:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: null

imagePullSecrets:
  - name: ghcr-pull-secret

batch:
  enabled: true
  schedule: "0 * * * *"    # every hour
  intervalSeconds: 3600    # worker inside container runs every hour too

# auto-generated DSN using PostgreSQL chart:
dbPostgresURL: >-
  postgres://{{ .Values.postgresql.auth.username }}:{{ .Values.postgresql.auth.password }}
  @{{ include "eratemanager.fullname" . }}-postgresql:5432/
  {{ .Values.postgresql.auth.database }}?sslmode=disable