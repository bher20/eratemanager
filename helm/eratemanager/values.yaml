image:
  repository: ghcr.io/bher20/eratemanager
  tag: latest
  pullPolicy: IfNotPresent

replicaCount: 1

# PostgreSQL subchart configuration
postgresql:
  enabled: false
  # auth:
  #   username: <provided-at-runtime>
  #   password: <provided-at-runtime>
  #   database: eratemanager
  image:
    registry: docker.io
    repository: bitnami/postgresql
    tag: latest

db:
  # Use Postgres (postgrespool for connection pooling)
  driver: "postgrespool"
  # DSN is dynamically generated using the postgresql auth values if not provided here.
  # dsn: ""
  # Run database migrations on startup
  autoMigrate: true

cronWorker:
  # Runs the in-app cron worker as a long-lived Deployment. It uses intervalSeconds
  # for the internal refresh loop (seconds or cron syntax) and reads settings from
  # the DB when present. Enable this when you want the app to self-schedule refreshes.
  enabled: false
  replicaCount: 1
  resources: {}
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80


service:
  type: ClusterIP
  port: 80

app:
  port: 8000
  publicURL: "http://localhost:8000"

# Providers are now discovered dynamically via the /providers API endpoint.
# No need to list them here - the helm chart will query the running application.

# Refresh hook runs after install/upgrade to populate data for all discovered providers
refreshHook:
  enabled: true

persistence:
  enabled: false
  size: 1Gi
  mountPath: /data

gateway:
  enabled: false
  name: public-gateway
  namespace: default
  hostname: rates.example.com

monitoring:
  enabled: false
  serviceMonitor:
    enabled: true
    namespace: ""
    interval: 30s
    scrapeTimeout: 10s
    labels: {}

hpa:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: null

imagePullSecrets: []
  # - name: ghcr-pull-secret

batch:
  # Creates a Kubernetes CronJob that runs `/eratemanager batch` on the cluster
  # schedule below. The CronJob handles scheduling; the container also reads
  # intervalSeconds (seconds) for its own inner loop. Use this for cluster-managed
  # batch runs instead of the long-lived cron worker.
  enabled: true
  schedule: "0 * * * *"    # every hour
  intervalSeconds: 3600    # worker inside container runs every hour too
