import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict

from .downloader import download_pdf
from .normalizer import normalize
from .parser import parse_pdf
from .diffing import (
    DEFAULT_SNAPSHOT_PATH,
    load_snapshot,
    extract_residential_summary,
    diff_summaries,
    format_changes_console,
)


def _load_current_parsed(force: bool = False) -> Dict[str, Any]:
    pdf_path = download_pdf(force=force)
    return parse_pdf(str(pdf_path))


def cmd_fetch(args: argparse.Namespace) -> int:
    parsed = _load_current_parsed(force=args.force)
    normalized = normalize(parsed)

    if args.raw:
        print(json.dumps(parsed, indent=2, default=str))
        return 0

    # residential view
    rates = normalized.get("rates", {})
    if args.residential:
        rs = rates.get("residential_standard")
        srs = rates.get("residential_supplemental")

        output = {
            "residential_standard": rs,
            "residential_supplemental": srs,
        }

    else:
        output = normalized

    print(json.dumps(output, indent=2, default=str))
    return 0


def cmd_compare(args: argparse.Namespace) -> int:
    parsed = _load_current_parsed(force=args.force)
    current_summary = extract_residential_summary(parsed)

    snapshot_path = Path(args.snapshot) if args.snapshot else DEFAULT_SNAPSHOT_PATH
    snapshot = load_snapshot(snapshot_path)

    baseline_summary = {
        "residential_standard": snapshot["residential_standard"],
        "residential_supplemental": snapshot["residential_supplemental"],
    }

    changes = diff_summaries(current_summary, baseline_summary)

    if not changes:
        print("No rate changes detected.")
        return 0

    print(format_changes_console(changes))
    # Non-zero exit so automation can detect change if desired
    return 1


def cmd_snapshot_create(args: argparse.Namespace) -> int:
    parsed = _load_current_parsed(force=args.force)
    summary = extract_residential_summary(parsed)

    if args.output:
        out_path = Path(args.output)
    else:
        out_path = DEFAULT_SNAPSHOT_PATH

    out_path.parent.mkdir(parents=True, exist_ok=True)

    snapshot = {
        "residential_standard": summary["residential_standard"],
        "residential_supplemental": summary["residential_supplemental"],
        "metadata": {
            "note": "Generated by cemc-rates CLI snapshot create",
        },
    }

    out_path.write_text(json.dumps(snapshot, indent=2))
    print(f"Snapshot written to {out_path}")
    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="cemc-rates",
        description="CLI for fetching and comparing CEMC residential energy rates.",
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    # fetch
    p_fetch = subparsers.add_parser(
        "fetch",
        help="Fetch current rates and print them as JSON.",
    )
    p_fetch.add_argument(
        "--residential",
        action="store_true",
        help="Print only residential (standard + supplemental) rates (default).",
    )
    p_fetch.add_argument(
        "--raw",
        action="store_true",
        help="Print raw parsed PDF data instead of normalized rates.",
    )
    p_fetch.add_argument(
        "--force",
        action="store_true",
        help="Force re-download of the PDF (ignore cached file).",
    )
    p_fetch.set_defaults(func=cmd_fetch)

    # compare
    p_compare = subparsers.add_parser(
        "compare",
        help="Compare current PDF rates to the snapshot and show differences.",
    )
    p_compare.add_argument(
        "--snapshot",
        type=str,
        default=None,
        help=f"Path to snapshot JSON (default: {DEFAULT_SNAPSHOT_PATH})",
    )
    p_compare.add_argument(
        "--force",
        action="store_true",
        help="Force re-download of the PDF (ignore cached file).",
    )
    p_compare.set_defaults(func=cmd_compare)

    # snapshot create
    p_snap = subparsers.add_parser(
        "snapshot",
        help="Manage snapshots (currently supports: snapshot create).",
    )
    snap_sub = p_snap.add_subparsers(dest="snapshot_command", required=True)

    p_snap_create = snap_sub.add_parser(
        "create",
        help="Create or overwrite a snapshot from the current PDF.",
    )
    p_snap_create.add_argument(
        "--output",
        type=str,
        default=None,
        help=f"Output snapshot path (default: {DEFAULT_SNAPSHOT_PATH})",
    )
    p_snap_create.add_argument(
        "--force",
        action="store_true",
        help="Force re-download of the PDF (ignore cached file).",
    )
    p_snap_create.set_defaults(func=cmd_snapshot_create)

        # refresh-pdf
    p_refresh = subparsers.add_parser(
        "refresh-pdf",
        help="Force download of the latest CEMC PDF into the cache.",
    )
    p_refresh.set_defaults(func=cmd_refresh_pdf)


    return parser


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    # Support "cemc-rates snapshot create" properly
    if getattr(args, "command", None) == "snapshot" and getattr(
        args, "snapshot_command", None
    ) is None:
        parser.error("snapshot subcommand required (e.g. 'snapshot create').")

    func = getattr(args, "func", None)
    if func is None:
        parser.print_help()
        sys.exit(1)

    code = func(args)
    raise SystemExit(code)

def cmd_refresh_pdf(args: argparse.Namespace) -> int:
    """Refresh the PDF by forcing a re-download into the cache directory."""
    pdf_path = download_pdf(force=True)
    print(f"PDF refreshed: {pdf_path}")
    return 0
